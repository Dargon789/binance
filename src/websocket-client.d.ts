/// <reference types="node" />
import { AxiosRequestConfig } from 'axios';
import { EventEmitter } from 'events';
import WebSocket from 'isomorphic-ws';
import { DefaultLogger } from './logger';
import { KlineInterval } from './types/shared';
import { WsFormattedMessage, WsRawMessage, WsResponse, WsUserDataEvents } from './types/websockets';
import { RestClientOptions } from './util/requestUtils';
export interface WSClientConfigurableOptions {
    api_key?: string;
    api_secret?: string;
    beautify?: boolean;
    disableHeartbeat?: boolean;
    pongTimeout?: number;
    pingInterval?: number;
    reconnectTimeout?: number;
    restOptions?: RestClientOptions;
    requestOptions?: AxiosRequestConfig;
    wsOptions?: {
        protocols?: string[];
        agent?: any;
    };
    wsUrl?: string;
}
export interface WebsocketClientOptions extends WSClientConfigurableOptions {
    pongTimeout: number;
    pingInterval: number;
    reconnectTimeout: number;
}
export type WsKey = string | 'spot' | 'margin' | 'usdmfutures' | 'coinmfutures' | 'options';
export declare interface WebsocketClient {
    on(event: 'reply', listener: (event: WsResponse) => void): this;
    on(event: 'message', listener: (event: WsRawMessage) => void): this;
    on(event: 'formattedMessage', listener: (event: WsFormattedMessage) => void): this;
    on(event: 'formattedUserDataMessage', listener: (event: WsUserDataEvents) => void): this;
    on(event: 'error', listener: (event: {
        wsKey: WsKey;
        error: any;
        rawEvent?: string;
    }) => void): this;
    on(event: 'open' | 'reconnected' | 'reconnecting' | 'close', listener: (event: {
        wsKey: WsKey;
        ws: WebSocket;
        event?: any;
    }) => void): this;
}
export declare function parseRawWsMessage(event: any): any;
export declare class WebsocketClient extends EventEmitter {
    private logger;
    private options;
    private wsStore;
    private beautifier;
    private restClients;
    private listenKeyStateStore;
    private wsUrlKeyMap;
    constructor(options: WSClientConfigurableOptions, logger?: typeof DefaultLogger);
    private getRestClientOptions;
    connectToWsUrl(url: string, wsKey?: WsKey, forceNewConnection?: boolean): WebSocket;
    tryWsSend(wsKey: WsKey, wsMessage: string): void;
    tryWsPing(wsKey: WsKey): void;
    private onWsOpen;
    private onWsClose;
    private onWsMessage;
    private sendPing;
    private onWsPing;
    private onWsPong;
    private executeReconnectableClose;
    close(wsKey: WsKey, shouldReconnectAfterClose?: boolean): void;
    closeAll(shouldReconnectAfterClose?: boolean): void;
    closeWs(ws: WebSocket, shouldReconnectAfterClose?: boolean): void;
    private parseWsError;
    private reconnectWithDelay;
    private clearTimers;
    private clearPingTimer;
    private clearPongTimer;
    private clearReconnectTimer;
    private clearUserDataKeepAliveTimer;
    private getWsBaseUrl;
    getWs(wsKey: WsKey): WebSocket | undefined;
    private setWsState;
    private getSpotRestClient;
    private getUSDMRestClient;
    private getCOINMRestClient;
    private requestSubscribeTopics;
    private requestUnsubscribeTopics;
    requestListSubscriptions(wsKey: WsKey, requestId: number): void;
    requestSetProperty(wsKey: WsKey, property: 'combined' | string, value: any, requestId: number): void;
    requestGetProperty(wsKey: WsKey, property: 'combined' | string, requestId: number): void;
    private getListenKeyState;
    private setKeepAliveListenKeyTimer;
    private sendKeepAliveForMarket;
    private checkKeepAliveListenKey;
    private teardownUserDataListenKey;
    private respawnUserDataStream;
    subscribeEndpoint(endpoint: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeAggregateTrades(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeTrades(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeCoinIndexPrice(symbol: string, updateSpeedMs?: 1000 | 3000, forceNewConnection?: boolean): WebSocket;
    subscribeMarkPrice(symbol: string, market: 'usdm' | 'coinm', updateSpeedMs?: 1000 | 3000, forceNewConnection?: boolean): WebSocket;
    subscribeAllMarketMarkPrice(market: 'usdm' | 'coinm', updateSpeedMs?: 1000 | 3000, forceNewConnection?: boolean): WebSocket;
    subscribeKlines(symbol: string, interval: KlineInterval, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeContinuousContractKlines(symbol: string, contractType: 'perpetual' | 'current_quarter' | 'next_quarter', interval: KlineInterval, market: 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeIndexKlines(symbol: string, interval: KlineInterval, forceNewConnection?: boolean): WebSocket;
    subscribeMarkPriceKlines(symbol: string, interval: KlineInterval, forceNewConnection?: boolean): WebSocket;
    subscribeSymbolMini24hrTicker(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeAllMini24hrTickers(market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeSymbol24hrTicker(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeAll24hrTickers(market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeAllRollingWindowTickers(market: 'spot', windowSize: '1h' | '4h' | '1d', forceNewConnection?: boolean): WebSocket;
    subscribeSymbolBookTicker(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeAllBookTickers(market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeSymbolLiquidationOrders(symbol: string, market: 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeAllLiquidationOrders(market: 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribePartialBookDepths(symbol: string, levels: 5 | 10 | 20, updateMs: 100 | 250 | 500 | 1000, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeDiffBookDepth(symbol: string, updateMs: 100 | 250 | 500 | 1000, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeContractInfoStream(market: 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    subscribeSpotAggregateTrades(symbol: string, forceNewConnection?: boolean): WebSocket;
    subscribeSpotTrades(symbol: string, forceNewConnection?: boolean): WebSocket;
    subscribeSpotKline(symbol: string, interval: KlineInterval, forceNewConnection?: boolean): WebSocket;
    subscribeSpotSymbolMini24hrTicker(symbol: string, forceNewConnection?: boolean): WebSocket;
    subscribeSpotAllMini24hrTickers(forceNewConnection?: boolean): WebSocket;
    subscribeSpotSymbol24hrTicker(symbol: string, forceNewConnection?: boolean): WebSocket;
    subscribeSpotAll24hrTickers(forceNewConnection?: boolean): WebSocket;
    subscribeSpotSymbolBookTicker(symbol: string, forceNewConnection?: boolean): WebSocket;
    subscribeSpotAllBookTickers(forceNewConnection?: boolean): WebSocket;
    subscribeSpotPartialBookDepth(symbol: string, levels: 5 | 10 | 20, updateMs?: 1000 | 100, forceNewConnection?: boolean): WebSocket;
    subscribeSpotDiffBookDepth(symbol: string, updateMs?: 1000 | 100, forceNewConnection?: boolean): WebSocket;
    subscribeSpotUserDataStreamWithListenKey(listenKey: string, forceNewConnection?: boolean, isReconnecting?: boolean): WebSocket | undefined;
    subscribeSpotUserDataStream(forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket | undefined>;
    subscribeMarginUserDataStream(forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket>;
    subscribeIsolatedMarginUserDataStream(symbol: string, forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket>;
    subscribeUsdFuturesUserDataStream(isTestnet?: boolean, forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket>;
    subscribeCoinFuturesUserDataStream(isTestnet?: boolean, forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket>;
}
